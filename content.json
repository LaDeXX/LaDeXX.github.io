{"posts":[{"title":"我不会简单组合数学","text":"CF2077C. Binary Subsequence Value Sum。 容易发现这个 F(s,l,r)F(s,l,r)F(s,l,r) 事实上就是字符串 sss 中 [l,r][l,r][l,r] 这一段的 1\\mathtt{1}1 的个数减去 0\\mathtt{0}0 的个数。先考虑一个字符串怎么求出分数。 我们需要找到一个分界点 ppp，然后把左边的 FFF 值和右边的 FFF 值乘起来要求最大。观察到左右 FFF 值之和为定值，即整个字符串 1\\mathtt{1}1 的个数减去 0\\mathtt{0}0 的个数。于是猜想当左右 FFF 值各取一半时最大，或者当和为奇数的时候一个是一半上取整，一个是一半下取整是最大。答案确实如此，因为一定能找到一个 ppp，使得左右的 FFF 值满足这个。简单说明一下，能发现 ppp 每向后移动一位，左边的 FFF 值只会加一或减一，变化是连续的，因此一定能找到一个 ppp 使得左边的 FFF 值为一半，此时右边也相应满足。于是记 c0c_0c0​ 表示字符串 0\\mathtt{0}0 的个数，c1c_1c1​ 表示字符串 1\\mathtt{1}1 的个数，则价值为： ⌊(c1−c0)24⌋=(c1−c0)24−(c1−c0) mod 24.\\left\\lfloor\\frac{(c_1-c_0)^2}{4}\\right\\rfloor=\\frac{(c_1-c_0)^2}{4}-\\frac{(c_1-c_0)\\bmod 2}{4}. ⌊4(c1​−c0​)2​⌋=4(c1​−c0​)2​−4(c1​−c0​)mod2​. 你能发现一个序列的价值只和 01\\mathtt{01}01 个数之差有关。我们再来计算原序列的子序列的价值之和。我们考虑记 0\\mathtt{0}0 权值为 −1-1−1，1\\mathtt{1}1 权值为 111，然后一个字符串的价值就是其权值之和平方的下取整。对于一个 c0c_0c0​ 个 0\\mathtt{0}0，c1c_1c1​ 个 1\\mathtt{1}1 的字符串，我们统计它价值为 kkk 的子序列个数。我们枚举他选择了 iii 个 0\\mathtt{0}0，那么此时他选择了 k+ik+ik+i 个 1\\mathtt{1}1，那么总子序列个数就是： ∑i=0c0(c0i)(c1k+i)=∑i=0c0(c0c0−i)(c1k+i)=(c0+c1k+c0)=(nk+c0).\\sum_{i=0}^{c_0}\\binom{c_0}{i}\\binom{c_1}{k+i}=\\sum_{i=0}^{c_0}\\binom{c_0}{c_0-i}\\binom{c_1}{k+i}=\\binom{c_0+c_1}{k+c_0}=\\binom{n}{k+c_0}. i=0∑c0​​(ic0​​)(k+ic1​​)=i=0∑c0​​(c0​−ic0​​)(k+ic1​​)=(k+c0​c0​+c1​​)=(k+c0​n​). 左边的求和是一个范德蒙德卷积的推论。所以这个字符串所以子序列的价值之和就是： ∑i=−c0n−c0(nc0+i)(i24+i mod 24).\\sum_{i=-c_0}^{n-c_0}\\binom{n}{c_0+i}\\left(\\frac{i^2}{4}+\\frac{i\\bmod 2}{4}\\right). i=−c0​∑n−c0​​(c0​+in​)(4i2​+4imod2​). 预处理出所有 c0c_0c0​ 的答案即可 O(1)O(1)O(1) 询问，总复杂度 O(nlog⁡n+q)O(n\\log n+q)O(nlogn+q)，因为这里的处理需要简单 poly，具体可以看官解的代码（Python）。 我是 poly 菜鸡，于是我没有场切，所以我开始推狮子。这里需要的一些组合数性质可以先看 oiwiki。 我们把后面的取模分开处理。先求前面的平方除以四，再求后面的取模求和，这里我们可以把除以四放在最后，所以推式子里面没写。 ∑i=−c0n−c0(nc0+i)i2=∑i=0n(ni)(i−c0)2=∑i=0n(ni)i2−2c0∑i=0n(ni)i+c02∑i=0n(ni)=n(n+1)2n−2−2c0n2n−1+c022n.∑i=−c0n−c0(ni+c0)(i mod 2)=∑i=0n(ni)((i−c0) mod 2)=2n−1.\\begin{aligned} \\sum_{i=-c_0}^{n-c_0}\\binom{n}{c_0+i}i^2&amp;=\\sum_{i=0}^n\\binom{n}{i}(i-c_0)^2\\\\ &amp;=\\sum_{i=0}^n\\binom{n}{i}i^2-2c_0\\sum_{i=0}^n\\binom{n}{i}i+c_0^2\\sum_{i=0}^n\\binom{n}{i}\\\\ &amp;=n(n+1)2^{n-2}-2c_0n2^{n-1}+c_0^22^n.\\\\ \\sum_{i=-c_0}^{n-c_0}\\binom{n}{i+c_0}(i\\bmod 2)&amp;=\\sum_{i=0}^n\\binom{n}{i}\\left((i-c_0)\\bmod 2\\right)=2^{n-1}. \\end{aligned} i=−c0​∑n−c0​​(c0​+in​)i2i=−c0​∑n−c0​​(i+c0​n​)(imod2)​=i=0∑n​(in​)(i−c0​)2=i=0∑n​(in​)i2−2c0​i=0∑n​(in​)i+c02​i=0∑n​(in​)=n(n+1)2n−2−2c0​n2n−1+c02​2n.=i=0∑n​(in​)((i−c0​)mod2)=2n−1.​ 说明一下后面这个式子。他的具体意义就是求出所有 iii 为偶数或奇数的组合数之和。不论奇数还是偶数，组合数之和都是 2n−12^{n-1}2n−1 次方。 证明：考虑二项式定理，我们有 (1+x)n=∑i=0n(ni)xi(1+x)^n=\\sum_{i=0}^n \\binom{n}{i}x^i(1+x)n=∑i=0n​(in​)xi，代入 x=−1x=-1x=−1： (1−1)n=∑i=0n(ni)(−1)i=0.(1-1)^n=\\sum_{i=0}^n \\binom{n}{i}(-1)^i=0. (1−1)n=i=0∑n​(in​)(−1)i=0. 即： ∑i mod 2=0(ni)−∑i mod 2=1(ni)=0\\sum_{i\\bmod 2=0}\\binom{n}{i}-\\sum_{i\\bmod 2=1}\\binom{n}{i}=0 imod2=0∑​(in​)−imod2=1∑​(in​)=0 也就是 iii 为奇数和偶数分别求和是相等的，并且我们知道所有组合数之和是 2n2^n2n，从而 iii 为奇或偶是的和都是 2n−12^{n-1}2n−1。 最后把两个式子加起来。 4Answer=n(n+1)2n−2−2c0n2n−1+c022n+2n−1,Answer=2n−4(n2+n−4c0n−4c02+2).\\begin{aligned} 4\\text{Answer}&amp;=n(n+1)2^{n-2}-2c_0n2^{n-1}+c_0^22^n+2^{n-1},\\\\ \\text{Answer}&amp;=2^{n-4}(n^2+n-4c_0n-4c_0^2+2). \\end{aligned}4AnswerAnswer​=n(n+1)2n−2−2c0​n2n−1+c02​2n+2n−1,=2n−4(n2+n−4c0​n−4c02​+2).​ 然后直接做了，每次询问 O(1)O(1)O(1) 算一下即可。代码就不放了，十分甚至九分的简单罢。","link":"/2025/03/13/CF2077C-sol/"},{"title":"根号带老哥，TLE 一车","text":"CF1039D. You Are Given a Tree。卡常不清新根号老哥贪心题。 给定一颗 nnn 个结点的树，对每个正整数 k∈[1,n]k\\in [1,n]k∈[1,n] 求出以下问题的答案： 最多能在树中选出多少条长为 kkk 的链使得这些链包含的点互不相交。 n≤105n\\leq 10^5n≤105。 如果钦定一个 kkk，那么可以直接 O(n)O(n)O(n) 树上贪心做，我认为这个并不像 dp，所以本文我打的 tag 并没有 dp。我们直接 DFS，对于一个点及其若干子节点，我们先让其子节点能选则选，最后会剩下了若干条从子节点连出去的链，我们记 f,gf,gf,g 分别是这些链中最长和次长的长度（如果链的数量不足那么就是 000）。那么有两种决策： 如果 f+g+1≥kf+g+1\\geq kf+g+1≥k，那么就把当前的根和左右最长次长的两个链连起来加入答案，当前节点就不向父亲连边。 否则当前节点（成为了其父亲的子节点）往下连出去的链最长为 f+1f+1f+1，然后返回父亲做同样的决策。 感性理解一下正确性，也就是证明子树内最优的时候全局也一定不劣。 我们容易发现子树内往子树外的链至多只有一条： 如果子树内为了往子树外连链，破坏了最优子树内选择的大于等于两条链，那么显然把前者删去然后连接后面的几条链更优。 如果子树内为了往子树外连链，破坏了最优子树内选择的恰好 111 条链，那么显然把前者换成后者一定不劣。 所以子树内部自己先贪心选完一定不劣。 然后对于所有的 kkk 怎么做，我们选择根号分治。我们把所有的 kkk 按 BBB 分为两部分，小于等于 BBB 的暴力做，时间复杂度 O(nB)O(nB)O(nB)，大于 BBB 的 kkk，能发现本质不同的答案至多只有 nB\\frac{n}{B}Bn​ 种，于是我们使用二分找到每种答案的 kkk 值区间端点然后输出，时间复杂度 O(n2log⁡nB)O(\\frac{n^2\\log n}{B})O(Bn2logn​)。总复杂度 O(nB+n2log⁡nB)O(nB+\\frac{n^2\\log n}{B})O(nB+Bn2logn​)，基本不等式可得 nB+n2log⁡nB≥2nnlog⁡nnB+\\frac{n^2\\log n}{B}\\geq 2n\\sqrt{n\\log n}nB+Bn2logn​≥2nnlogn​，此时 B=nlog⁡nB=\\sqrt{n\\log n}B=nlogn​。做完了，总时间复杂度 O(nnlog⁡n)O(n\\sqrt{n\\log n})O(nnlogn​)。 根号带老哥，TLE 一车，所以要轻微卡常，可以选择记忆化答案，以及不用递归 dfs 遍历树而是选择记录 dfn 序循环遍历。 这里还有一种不用直接的根号分治的复杂度相同的做法。 类比 数论分块，我们注意到答案种类 ≤2n\\leq 2\\sqrt n≤2n​，于是用类似数论分块的方法，但是寻找右端点使用二分，然后做完了，其实就是前面解法中分治后半段的做法。朴素实现 O(nnlog⁡n)O(n\\sqrt n \\log n)O(nn​logn)，记忆化后时间复杂度好像是 O(nnlog⁡n)O(n\\sqrt{n\\log n})O(nnlogn​)，笔者太菜不会证，但是你能发现这个做法和上面的做法本质相同，于是时间复杂度大概也相同。 123456789101112131415161718192021222324252627282930313233343536373839404142434445#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int N = 1e5 + 10;int n, T, Ans[N], F[N], idx[N], dfn[N], dfncnt, g[N]; vector&lt;int&gt; G[N];void DFS(int u, int f) { idx[++ dfncnt] = u; dfn[u] = dfncnt; for (int v : G[u]) if (v != f) DFS(v, u);}int Solve(int k) { if (F[k] != -1) return F[k]; if (k &gt; n) return 0; int cur = 0; for (int i = n; i &gt;= 1; i --) { int mx = 0, snd = 0, u = idx[i]; for (int v : G[u]) if (dfn[v] &gt; i) { if (g[v] &gt; mx) snd = mx, mx = g[v]; else snd = max(snd, g[v]); } if (mx + 1 + snd &gt;= k) ++ cur, g[u] = 0; else g[u] = mx + 1; } return F[k] = cur;}int main() { freopen(&quot;.in&quot;, &quot;r&quot;, stdin); freopen(&quot;.out&quot;, &quot;w&quot;, stdout); ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; T = sqrt(n * log2(n)); for (int i = 1, u, v; i &lt; n; i ++) { cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); } DFS(1, 0); memset(F, -1, sizeof F); for (int i = 1; i &lt;= T; i ++) Ans[i] = Solve(i); for (int i = n / (T + 1), lst = T; i &gt;= 1; i --) { int l = lst + 1, r = n + 1; if (l &gt; r) break; while (l + 1 &lt; r) { int mid = (l + r) &gt;&gt; 1; if (Solve(mid) &lt; i) r = mid; else l = mid; } int res = (Solve(l) &lt; i ? l - 1 : r - 1); for (int j = lst + 1; j &lt;= res; j ++) Ans[j] = i; lst = res; } for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; Ans[i] &lt;&lt; &quot;\\n&quot;; return 0;} 代码做法是前者。","link":"/2025/03/17/CF1039D-sol/"},{"title":"想要成为 DP 高手","text":"P6748 『MdOI R3』Fallen Lord。 树形 DP 好题。 我们先钦定 111 为根吧。容易发现一个点周围的边是否合法，和具体的边权大小无关，而和边权与点权的相对大小有关。。于是我们定义状态：fi,0/1f_{i,0/1}fi,0/1​ 表示点 iii 子树内的边和 iii 向父亲的边都已经确定了权值，子树内的点都合法了，并且连向父亲的边是或否大于父亲点权，最大的边权和。然后考虑转移。 先合并子节点状态，而不考虑父节点这条边。注意到为了满足合法条件，至多有 ⌊d−12⌋\\lfloor\\frac{d - 1}{2}\\rfloor⌊2d−1​⌋ 条连边是大于当前节点的权值的。我们求出 r0,r1r_0,r_1r0​,r1​，分别表示在通往子节点的边中选择了小于等于 ⌊d−12⌋\\lfloor\\frac{d-1}{2}\\rfloor⌊2d−1​⌋ 或 ⌊d−12⌋−1\\lfloor\\frac{d-1}{2}\\rfloor-1⌊2d−1​⌋−1 条大于当前点权的边，的最大边权和。求出 r1r_1r1​ 是为了考虑往父节点连一条大于当前点权的边这一情况。具体求解以 r0r_0r0​ 为例，我们先不考虑限制，在子节点的 fv,0/1f_{v,0/1}fv,0/1​ 中取 max⁡\\maxmax 直接求和，并把所有最大值取到 fv,1f_{v,1}fv,1​ 的 vvv 记录下来，假设有 ccc 个子节点取到了 fv,1f_{v,1}fv,1​，如果 c≤⌊d−12⌋c\\leq \\lfloor\\frac{d-1}{2}\\rfloorc≤⌊2d−1​⌋ 那么合法，否则我们需要更换 c−⌊d−12⌋c-\\lfloor\\frac{d-1}{2}\\rfloorc−⌊2d−1​⌋ 条边为小于当前点权。于是我们把这些选择了 fv,1f_{v,1}fv,1​ 的子节点按照 (fv,1−fv,0)(f_{v,1}-f_{v,0})(fv,1​−fv,0​) 升序排序并取前 c−⌊d−12⌋c-\\lfloor\\frac{d-1}{2}\\rfloorc−⌊2d−1​⌋ 小的即可。 在求出了 r0,r1r_0,r_1r0​,r1​ 之后，再来解决当前节点的 fff 状态。记 uuu 为当前节点，ppp 为父节点。对于 r0,r1r_0,r_1r0​,r1​，我们有一种另外的解释，r0r_0r0​ 即为连向父亲的边只能小于等于 aua_uau​ 的边权，子树的答案，r1r_1r1​ 则表示连向父亲的边任意，子树的答案。轻微分讨一下： 当 ap&lt;aua_p &lt; a_uap​&lt;au​​ 时，有以下两种转移： fu,0←max⁡(r0,r1)+ap.f_{u,0}\\leftarrow\\max(r_0,r_1)+a_p.fu,0​←max(r0​,r1​)+ap​. fu,1←max⁡(r0+au,r1+m).f_{u,1}\\leftarrow \\max(r_0+a_u,r_1+m).fu,1​←max(r0​+au​,r1​+m). 当 ap≥aua_p \\geq a_uap​≥au​​ 时，有以下两种转移： fu,0←max⁡(r0+au,r1+ap).f_{u,0}\\leftarrow\\max(r_0+a_u,r_1+a_p).fu,0​←max(r0​+au​,r1​+ap​). fu,1←r1+m.f_{u,1}\\leftarrow r_1+m.fu,1​←r1​+m. 然后做完了。答案显然就是根节点的 r0r_0r0​ 值。注意要考虑当 ⌊d−12⌋=0\\lfloor\\frac{d - 1}{2}\\rfloor=0⌊2d−1​⌋=0 以及叶子节点之类的 corner case。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int N = 5e5 + 10;int n; LL m, A[N], DP[N][2]; vector&lt;int&gt; G[N];void DFS(int u, int f) { if (G[u].size() - (f &gt; 0) == 0) { if (A[f] &gt;= A[u]) DP[u][0] = A[u], DP[u][1] = -1e15; else DP[u][0] = A[f], DP[u][1] = A[u]; return ; } for (int v : G[u]) if (v != f) DFS(v, u); int d = ((int)G[u].size() - 1) / 2, cnt = 0; vector&lt;LL&gt; tmp; LL res1 = 0, res0 = 0; for (int v : G[u]) if (v != f) { res1 += max(DP[v][0], DP[v][1]); if (DP[v][1] &gt; DP[v][0]) tmp.emplace_back(DP[v][1] - DP[v][0]), ++ cnt; } sort(tmp.begin(), tmp.end()); res0 = res1; for (int i = 0; i &lt; cnt - d; i ++) res0 -= tmp[i]; if (!f) { DP[u][0] = res0; return ; } if (!d) { if (A[f] &gt;= A[u]) DP[u][0] = res0 + A[u], DP[u][1] = -1e15; else DP[u][0] = res0 + A[f], DP[u][1] = res0 + A[u]; return ; } for (int i = 0; i &lt; cnt - d + 1; i ++) res1 -= tmp[i]; if (A[f] &gt;= A[u]) DP[u][0] = max(res1 + A[f], res0 + A[u]), DP[u][1] = res1 + m; else DP[u][0] = max(res0, res1) + A[f], DP[u][1] = max(res0 + A[u], res1 + m);}int main() { ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; if (!n) { cout &lt;&lt; &quot;0\\n&quot;; return 0; } for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; A[i]; for (int i = 1, u, v; i &lt; n; i ++) { cin &gt;&gt; u &gt;&gt; v; G[u].emplace_back(v); G[v].emplace_back(u); } DFS(1, 0); cout &lt;&lt; DP[1][0] &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2025/03/17/P6748-sol/"},{"title":"[Ynoi2007] rfplca - Solution","text":"Luogu P7446 [Ynoi2007] rfplca。 给定一棵以 111 为根树，nnn 个点，第 iii 个点的父亲是 aia_iai​，ai&lt;ia_i&lt;iai​&lt;i，QQQ 次询问，每次可能对 aia_iai​ 区间减法（对 111 取 max⁡\\maxmax），或者询问两个点的 LCA。 并非困难题，实际感觉也就紫。先考虑一个 naive 的弱化版： Luogu P3203 [HNOI2010] 弹飞绵羊。 题意为：有 nnn 个点，每个点有一个点权 aia_iai​ 表示从这个点向后跳一步可以跳到 i+aii+a_ii+ai​ 个点。QQQ 次询问，可以是修改点权，或者是询问从某个点开始跳几步会跳出这 nnn 个点。 考虑分块，设块长为 BBB，我们考虑处理出 pip_ipi​ 和 cic_ici​ 两个数组，分别表示向后跳第一次跳出所在块到达了哪个点，以及前面这个过程跳了几次。预处理显然是暴力做，时间复杂度 O(nB)O(nB)O(nB)。每次修改则暴力修改块内，时间复杂度 O(B)O(B)O(B)，询问则每次只需要按照 pip_ipi​ 跳即可，会发现每跳一次至少走过一个块，则之多跳 O(nB)O(\\frac{n}{B})O(Bn​) 次。n,qn,qn,q 同阶，总时间复杂度 O(nB+nnB)O(nB+n\\frac{n}{B})O(nB+nBn​)，取 B=nB=\\sqrt{n}B=n​ 最优，时间复杂度 O(nn)O(n\\sqrt n)O(nn​)，空间复杂度 O(n)O(n)O(n)。 回到本题，我们也考虑处理出 pip_ipi​ 数组表示第一次跳父亲跳出块内时所在的点。那么我们的询问 LCA 就有以下过程： 如果 u=vu=vu=v，则 LCA 为 uuu，结束询问。 如果 pu≠pvp_u\\neq p_vpu​=pv​，设 xxx 为 u,vu,vu,v 中 ppp 值较小的哪一个，使 x←pxx\\leftarrow p_xx←px​，即大跳一步，然后重新这个过程。 设 xxx 为 u,vu,vu,v 中的较小值，使 x←axx\\leftarrow a_xx←ax​，也即小跳一步，然后重新这个过程。 能发现大跳的次数不超过块个数，小跳的次数不超过块长，于是复杂度是 O(B+nB)O(B+\\frac{n}{B})O(B+Bn​) 的。 再来考虑修改。首先对左右两端的散块暴力重构 ppp 数组。对于整块的修改，我们注意到至多修改 BBB 次，这个整块中任意一个点跳一次就会跳出这个块，即此时这个块中的所有 iii 都有 pi=aip_i=a_ipi​=ai​。所以我们记录一个 cic_ici​ 表示第 iii 个块被整块修改的次数，如果 ci≥Bc_i\\geq Bci​≥B，我们就直接整块打懒标记维护 aia_iai​ 的减法，否则暴力重构。所以修改的总复杂度是 O(nB)O(nB)O(nB) 的。因为 n,qn,qn,q 同阶，所以总复杂度 O(n(B+Bn))O(n(B+\\frac{B}{n}))O(n(B+nB​))，当 B=nB=\\sqrt nB=n​ 的时候取到最值等于 O(nn)O(n\\sqrt n)O(nn​)。 这题居然不卡常，拜谢 lxl。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int N = 4e5 + 10;const int M = 640;int n, Q, m, T, A[N];int f[N], nxt[N], L[M], R[M], bel[N], tag[M], cnt[N];void rebuild(int x) { for (int i = L[x]; i &lt;= R[x]; i ++) { f[i] = max(1, f[i] - tag[x]); nxt[i] = (f[i] &lt; L[x] ? f[i] : nxt[f[i]]); } tag[x] = 0;}void update(int x, int y, int k) { if (bel[x] == bel[y]) { for (int i = x; i &lt;= y; i ++) f[i] = max(f[i] - k, 1); rebuild(bel[x]); return ; } for (int i = x; i &lt;= R[bel[x]]; i ++) f[i] = max(f[i] - k, 1); for (int i = L[bel[y]]; i &lt;= y; i ++) f[i] = max(f[i] - k, 1); rebuild(bel[x]), rebuild(bel[y]); for (int i = bel[x] + 1; i &lt;= bel[y] - 1; i ++) { if (cnt[i] &lt; T) { for (int j = L[i]; j &lt;= R[i]; j ++) f[j] = max(f[j] - k, 1); rebuild(i); cnt[i] ++; } else cnt[i] ++, tag[i] += k; } return ;}int getf(int x) { if (cnt[bel[x]] &lt; T) return f[x]; return max(1, f[x] - tag[bel[x]]);}int getnxt(int x) { if (cnt[bel[x]] &lt; T) return nxt[x]; return max(1, f[x] - tag[bel[x]]);}int query(int x, int y) { while (1) { int a = getnxt(x), b = getnxt(y); if (a == b) break; if (a &gt; b) x = a; else y = b; } while (x != y) { if (x &gt; y) x = getf(x); else y = getf(y); } return x;}int main() { freopen(&quot;.in&quot;, &quot;r&quot;, stdin); freopen(&quot;.out&quot;, &quot;w&quot;, stdout); ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; Q; T = sqrt(n); m = (n - 1) / T + 1; for (int i = 2; i &lt;= n; i ++) cin &gt;&gt; A[i], f[i] = A[i]; for (int i = 1; i &lt;= m; i ++) { L[i] = R[i - 1] + 1, R[i] = min(n, R[i - 1] + T); for (int j = L[i]; j &lt;= R[i]; j ++) { bel[j] = i; if (j == 1) { nxt[j] = j; continue; } nxt[j] = (f[j] &lt; L[i] ? f[j] : nxt[f[j]]); } } int lst = 0, opt, x, y, k; while (Q --) { cin &gt;&gt; opt &gt;&gt; x &gt;&gt; y; x ^= lst, y ^= lst; if (opt == 1) { cin &gt;&gt; k; k ^= lst; update(x, y, k); } else cout &lt;&lt; (lst = query(x, y)) &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2025/03/15/P7446-sol/"},{"title":"这种简单题怎么你谷评了紫 &#x2F;qd","text":"ABC267G - Increasing K Times。 容易发现这个数数和原数组顺序无关，首先对原数组排序，从小往大插入数。 我们记 fi,jf_{i,j}fi,j​ 表示插入了前 iii 个数，有 kkk 个位置满足小于的关系。然后考虑转移。我们后面插入一个数，注意到要么使得满足小于的位置数不变，要么加一。我们记 ccc 表示前 iii 个数中等于第 iii 个数的数的个数，有转移： fi−1,j×(j+c)→fi,jf_{i-1,j}\\times(j+c)\\rightarrow f_{i,j}fi−1,j​×(j+c)→fi,j​，因为把当前这个数填在这 jjj 个满足小于的位置之后能发现满足的位置个数仍然不变，或者把当前数填在和他相同的 c−1c-1c−1 个数之后，或者序列开头，也不变，一共 (j+c)(j+c)(j+c) 中填法。 fi−1,j×(i−j−c)→fi,j+1f_{i-1,j}\\times(i-j-c)\\rightarrow f_{i,j+1}fi−1,j​×(i−j−c)→fi,j+1​，除去上一种情况的位置都会使得合法位置加一。 初始值 f1,0=1f_{1,0}=1f1,0​=1，最后答案就是 fn,kf_{n,k}fn,k​。于是做完了。代码很简单。 锐评一下你谷评级，紫也是神人了，感觉只有蓝啊，都能被我做出来。 1234567891011121314151617181920212223#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const LL MOD = 998244353;const int N = 5e3 + 10;int n, K, A[N]; LL DP[N][N];int main() { freopen(&quot;.in&quot;, &quot;r&quot;, stdin); freopen(&quot;.out&quot;, &quot;w&quot;, stdout); ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; K; for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; A[i]; sort(A + 1, A + 1 + n); DP[1][0] = 1; for (int i = 1, c = 1; i &lt; n; i ++) { if (A[i] != A[i + 1]) c = 1; else ++ c; for (int j = 0; j &lt; i; j ++) { (DP[i + 1][j] += DP[i][j] * (c + j) % MOD) %= MOD; (DP[i + 1][j + 1] += DP[i][j] * (i + 1 - c - j) % MOD) %= MOD; } } cout &lt;&lt; DP[n][K] &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2025/03/17/at_abc267_g-sol/"},{"title":"multiset 笑传之查（find）查棒","text":"ABC217H - Snuketoon。 前言：大家好，我喜欢用 multiset 维护可重集，并且删除一个元素 xxx 的时候使用了 multiset.erase(x) 而不是 multiset.erase(multiset.find(x))，成功导致我保龄并调试 40 mins40\\ \\text{mins}40 mins，祝大家不要重蹈覆辙。 这个 dp 是 O(nV)O(nV)O(nV) 的，直接倒闭了。然后你能发现这个转移的增量是一个关于 jjj 的凸函数，所以考虑 Slope Trick。先介绍一下 Slope Trick。 Slope Trick 可以维护一个由若干段一次函数组成的一个凸分段函数。我们考虑记录这若干段一次函数的分界点的集合，并且分界点出现一次表示斜率增加或减少 111，如果出现多次则说明减少若干斜率，以及记录这个凸函数最开始那一段的 k,bk,bk,b，比如： f(x)={1−x,x≤5,2x+8,x&gt;5.f(x)=\\left\\{\\begin{aligned}&amp;1-x,\\quad&amp;x\\leq 5,\\\\&amp;2x+8,&amp;x&gt;5.\\end{aligned}\\right. f(x)={​1−x,2x+8,​x≤5,x&gt;5.​ 这个函数在 Slope Trick 下维护出的集合就是 {5,5,5}\\{5,5,5\\}{5,5,5}，以及最开始一段的函数的 k=−1,b=1k=-1,b=1k=−1,b=1。所以这是一个可重集。 然后你会发现这个东西比较优美，可以有如下的操作： 加上一个凸函数：因为凸函数加凸函数还是凸函数，所以直接把分界点集合合并即可，然后更新一下最开始一段的斜率和截距。 平移：对分段点集合打全局加减标记即可。 函数的最值：这里就不大相同，我们不维护最左边的斜率和截距。以凸函数为例，函数最大值就是斜率为 000 的部分，所以我们考虑维护两个集合分别表示斜率为 000 的左边和右边的分界点即可。最值就是中介斜率为 000 的部分。 函数取前后缀 min⁡/max⁡\\min/\\maxmin/max：联系上一点，就是把斜率为 000 的左边或者右边丢掉。 回到本题，我们设 Fi(j)=fi,jF_i(j)=f_{i,j}Fi​(j)=fi,j​，我们发现这个就是一个凸函数（函数凹凸的图像和汉字形状是相反的 /xk）。本题我们需要支持加上一个凸函数，并且维护最小值，然后考虑转移式前面的那个 min⁡\\minmin，这个就相当于把斜率为 000 左边的部分向左移 ttt，右边的部分向右移 ttt。对于 Ci(j)C_i(j)Ci​(j)，它在 Di=0D_i=0Di​=0 的时候是斜率由 −1-1−1 变为 000，否则是 000 变为 111。考虑加入这个凸函数的时候怎么更新斜率为 000 的部分并且更新答案。 以 Di=0D_i=0Di​=0 为例，这时候函数大致呈 \\_ 状。我们记当前斜率为 000 的一段区间为 [l,r][l,r][l,r]，如果这个函数的拐点 XXX 大于等于 lll，我们发现只需要 XXX 加入右集合即可。否则要更新这个区间和答案。先吧 XXX 加入左集合，我们会发现，原来斜率为 000 的这个区间斜率变成了 −1-1−1，所以把 rrr 加入右集合表示斜率减少 111，然后更新答案。 Di=1D_i=1Di​=1 同理。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int N = 2e5 + 10;int n; LL T[N], D[N], X[N], Ans = 0;struct Heap { multiset&lt;LL&gt; s; LL tag; void insert(LL x) { s.insert(x - tag); } void erase(LL x) { s.erase(s.find(x - tag)); } LL min() { return *s.begin() + tag; } LL max() { return *s.rbegin() + tag; } void add(LL x) { tag += x; }} pql, pqr;int main() { freopen(&quot;.in&quot;, &quot;r&quot;, stdin); freopen(&quot;.out&quot;, &quot;w&quot;, stdout); ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++) pql.insert(0), pqr.insert(0); for (int i = 1; i &lt;= n; i ++) { cin &gt;&gt; T[i] &gt;&gt; D[i] &gt;&gt; X[i]; LL len = T[i] - T[i - 1]; pql.add(-len); pqr.add(len); if (D[i]) { // _/ if (X[i] &gt;= pql.max()) { pqr.insert(X[i]); continue; } pql.insert(X[i]); LL r = pql.max(); pql.erase(r); pqr.insert(r); Ans += pqr.min() - X[i]; } else { // \\_ if (X[i] &lt;= pqr.min()) { pql.insert(X[i]); continue; } pqr.insert(X[i]); LL l = pqr.min(); pqr.erase(l); pql.insert(l); Ans += X[i] - pql.max(); } } cout &lt;&lt; Ans; return 0;}","link":"/2025/03/17/at_abc217_h-sol/"},{"title":"AT_abc395_g [ABC395G] Minimum Steiner Tree 2 Solution","text":"ABC395G - Minimum Steiner Tree 2 Solution。 根据题目名称，我们知道我们需要贺一个最小斯坦纳树板子。 但是我们会发现，他每次询问会在前 KKK 个点之外增加两个点 s,ts,ts,t，于是我们考虑预处理答案然后 O(1)O(1)O(1) 询问，我们枚举 s,ts,ts,t，然后暴力重新跑一遍最小斯坦纳树。时间复杂度 O(n2(n3k+2+n22k+2))O(n^2(n3^{k+2}+n^22^{k+2}))O(n2(n3k+2+n22k+2))，倒闭了。 观察最原始的最小斯坦纳树的状压 dp，状态定义为 fi,sf_{i,s}fi,s​ 表示以 iii 为当前根覆盖集合 sss，也就是说，有一维已经被最小斯坦纳树的 dp 枚举过了，于是我们只需要枚举一维 ttt，然后 s,ts,ts,t 的答案就是用 sss 覆盖了 {1,2,⋯ ,k,t}\\{1,2,\\cdots,k,t\\}{1,2,⋯,k,t}，即 fs,{1,2,⋯ ,k,t}f_{s,\\{1,2,\\cdots,k,t\\}}fs,{1,2,⋯,k,t}​，或者 s,ts,ts,t 互换一下。然后做完了。时间复杂度少了一个 nnn，指数也少了 111，O(n23k+1+n32k+1)O(n^23^{k+1}+n^3 2^{k+1})O(n23k+1+n32k+1)。 https://atcoder.jp/contests/abc395/submissions/63295857。","link":"/2025/03/17/at_abc395_g-sol/"},{"title":"AT_arc168_e [ARC168E] Subsegments with Large Sums Solution","text":"ARC168E - Subsegments with Large Sums。 wqs 二分好题。 看到恰好分成 kkk 段，于是往 wqs 二分去想，如果记 f(k)f(k)f(k) 表示分成 kkk 段的答案，你会发现这个不是凸的，然后我就烧烤半天毫无头猪。 换个地方考虑，我们发现答案是有单调性的，我们记 f(x)f(x)f(x) 表示答案为 xxx，即选出正好 xxx 个和大于 SSS 的区间是最多能分成多少段，则 f(x)f(x)f(x) 是递减的，我们需要找到最大的 xxx 满足 k≤f(x)k\\leq f(x)k≤f(x)。于是我们考虑二分答案 xxx，从而变成一个判定性问题：从序列中选出大于等于 xxx 段和大于 SSS 的区间，能否有一种方案使得区间总数大于 kkk。所以这里区间总数越大越好，于是有轻微贪心，我们记 pip_ipi​ 表示最后一个到 iii 的区间和大于等于 SSS 的位置，那么如果选择一个合法区间以 iii 结尾，那么一定左端点是 pip_ipi​，而非小于 pip_ipi​，并且除了合法区间以外的区间一定是单个数，这样选择的个数最多。这个 pip_ipi​ 可以直接双指针。 我们不妨想想如何清新地刻画这个区间个数，我们记一个区间的权值为其长度减一，那么你对原序列的一种划分区间方案中所有区间的权值之和就是 nnn 减去区间个数。于是我们的判定变成了：把序列划分成 kkk 段，并且有恰好 xxx 段和大于 SSS 的区间，求所有区间的权值之和最小值。如果最小值小于等于 n−kn-kn−k 说明 xxx 合法，否则不合法。 然后考虑这个子问题，发现我们记 g(i)g(i)g(i) 表示当 x=ix=ix=i 时上面这个问题的最小值，发现这是个凸函数（依照主流观点，向下凸出，是个下凸壳）。于是上 wqs 二分即可。 感性理解一下凸性，即证 g(i+1)−g(i)≥g(i)−g(i−1)g(i+1)-g(i)\\geq g(i)-g(i-1)g(i+1)−g(i)≥g(i)−g(i−1)。我们考虑这两次的决策，反证法，如果 g(i+1)−g(i)&lt;g(i)−g(i−1)g(i+1)-g(i)&lt; g(i)-g(i-1)g(i+1)−g(i)&lt;g(i)−g(i−1)，也就是说，当前第 i+1i+1i+1 次选择的区间的贡献小于第 iii 次选择的区间，因为我们要求的是最小值，那么显然前者可以在第 iii 次就选择，使得 g(i)g(i)g(i) 减小，从而使得 g(i)−g(i+1)≤g(i−1)−g(i)g(i)-g(i+1)\\leq g(i-1)-g(i)g(i)−g(i+1)≤g(i−1)−g(i)。 笔者代码实现中与上述描述唯一不同的是我记录的是 pi−1p_i - 1pi​−1 而不是 pip_ipi​。 https://atcoder.jp/contests/arc168/submissions/63405440。","link":"/2025/03/17/at_arc168_e-sol/"},{"title":"STL 颜面何在？如此成績，令人汗顏！","text":"ARC173C - Not Median。 今年 ARC 大賽，線性和線段樹做法大勝，STL 慘敗。羞也不羞，朋比為奸！我們需要嚴格的檢討！ 来一发 set 题解。 我们拿其中的某一个数 kkk 考虑，记序列中比它大的数为 000，比它小的为 111，手玩一下会发现是中位数情况只有两种： {⋯ ,0,1,0,1,k,0,1,0,1,⋯ },{⋯ ,1,0,1,0,k,1,0,1,0,⋯ }.\\{\\cdots,0,1,0,1,k,0,1,0,1,\\cdots\\},\\\\ \\{\\cdots,1,0,1,0,k,1,0,1,0,\\cdots\\}. {⋯,0,1,0,1,k,0,1,0,1,⋯},{⋯,1,0,1,0,k,1,0,1,0,⋯}. 也就是两边都 010101 交替，并且 kkk 两边不同为 000 或 111，那么非中位数的情况有： kkk 两边同为 000 或 111，答案为 333。 kkk 某一侧出现了连续两个同为 000 或 111，我们以右侧为例，记这两个连续相同的数的第二个的下标是 ppp，则当 p−k+1p-k+1p−k+1 为奇数时答案为 p−k+1p-k+1p−k+1，否则为 p−k+2p-k+2p−k+2。必要性是显然的因为区间长度必须奇数，但是充分性还需证明，为什么偶数时加入一个左边的数一定非法。我们假设 kkk 左侧相邻的数为 q∈{0,1}q\\in \\{0,1\\}q∈{0,1}，当 p−k+2p-k+2p−k+2 为偶数的时候，ppp 和 p−1p-1p−1 这两位上的 010101 等于 qqq（如果不等于 qqq，会归于上一种情况），而 kkk 到 ppp 这一段中当 ppp 这一位为 000 的时候大于 kkk 的更多，加上 qqq 这一位之后大于 kkk 的依然更多，所以不是中位数，当 ppp 这一位小于 000 同理，所以得证。当 ppp 在 kkk 左侧也同理，加入右侧第一个即可。 然后我们考虑维护，我们从小到大加入数字，标记为 111，便记录了这一个 010101 序列，然后用一个 setsetset 维护相邻相同的位置即可，每次 lower_bound 查询最近的第一个相邻就好了。 但是注意我们这样做需要保证 kkk 有左侧和右侧，所以序列首尾两个数要单独处理，会发现首尾两个数不是中位数是平凡的。以第一个数为例，[1,r][1,r][1,r] 这个序列可以作为答案当且仅当 rrr 是奇数并且 [2,r][2,r][2,r] 中大于 P1P_1P1​ 的个数不等于小于 P1P_1P1​ 的个数。这个也可以处理一个 010101 列然后前缀和一下。最后一个数也同理。 然后做完了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int N = 3e5 + 10;int n, A[N], id[N], Ans[N], B[N];int main() { ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; id[A[i]] = i, i ++) cin &gt;&gt; A[i]; memset(Ans, -1, sizeof Ans); for (int i = 2; i &lt;= n; i ++) B[i] = B[i - 1] + (A[i] &gt; A[1]); for (int i = 3; i &lt;= n; i += 2) if (B[i] != i / 2) { Ans[1] = i; break; } B[n] = 0; for (int i = n - 1; i &gt;= 1; i --) B[i] = B[i + 1] + (A[i] &gt; A[n]); for (int i = n - 2; i &gt;= 1; i -= 2) if (B[i] != (n - i) / 2) { Ans[n] = n - i + 1; break; } set&lt;int&gt; s; for (int i = 1; i &lt;= n - 1; i ++) s.insert(i); for (int i = 1; i &lt;= n; i ++) { int u = id[i]; if (u != 1 &amp;&amp; u != n) { if ((A[u - 1] &lt; A[u]) == (A[u + 1] &lt; A[u])) Ans[u] = 3; else { auto it = s.lower_bound(u + 1); if (it != s.end()) { int tmp = *it - u + 2; if (tmp % 2 == 0) ++ tmp; if (Ans[u] == -1) Ans[u] = tmp; else Ans[u] = min(Ans[u], tmp); } it = s.lower_bound(u - 1); if (it != s.begin()) { it --; int tmp = u - *it + 1; if (tmp % 2 == 0) ++ tmp; if (Ans[u] == -1) Ans[u] = tmp; else Ans[u] = min(Ans[u], tmp); } } } if (u &gt; 1) { if (A[u - 1] &lt; i) s.insert(u - 1); else s.erase(u - 1); } if (u &lt; n) { if (A[u + 1] &lt; i) s.insert(u); else s.erase(u); } } for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; Ans[i] &lt;&lt; &quot; \\n&quot;[i == n]; return 0;}","link":"/2025/03/13/at_arc173_c-sol/"},{"title":"不会套路题，我退役了。","text":"CF1107E Vasya and Binary String。简单套路区间 dp 题。 给定一个长度为 nnn 的 01 串，每次操作可以删除一个全部字符都相等的字串，然后拼接两边剩下的部分。删除长度为 xxx 的子串的代价是 axa_xax​，最大化删空原串的代价。n≤100,1≤ai≤109n\\leq 100,1\\leq a_i\\leq 10^9n≤100,1≤ai​≤109。 先容易想到的是确保连续删除的长度越长越不劣，于是处理出一个 a′a'a′ 数组，令 a0=1a_0=1a0​=1，有： ai′=max⁡j=1i(aj+ai−j).a'_i=\\max_{j=1}^i(a_j+a_{i-j}). ai′​=j=1maxi​(aj​+ai−j​). 然后考虑区间 dp，有一种朴素的做法是：容易发现一段区间删到最后一定剩下一堆相同的 01 然后和其他区间合并删掉，于是记 fl,r,i,0/1f_{l,r,i,0/1}fl,r,i,0/1​ 表示区间 [l,r][l,r][l,r] 删到最后还剩下 iii 个 0/10/10/1 的最大代价。然后枚举分割点 k∈[l,r)k\\in[l,r)k∈[l,r) 转移，因为枚举分割点合并左右区间的时候还要枚举一位 jjj 表示左边剩下了 jjj 个 0/10/10/1，右边剩下 i−ji-ji−j 个，因此总复杂度是 O(n5)O(n^5)O(n5) 的。 抛去这种做法的全部想法。我们记 fl,r,kf_{l,r,k}fl,r,k​ 表示删空区间 [l,r][l,r][l,r] 以及 rrr 右边的 kkk 个和他颜色相同的。于是有两种转移： fl,r,k←fl,r−1,0+ak+1′f_{l,r,k}\\leftarrow f_{l,r-1,0}+a'_{k+1}fl,r,k​←fl,r−1,0​+ak+1′​，表示把 rrr 及其以后的 k+1k+1k+1 个 0/10/10/1 直接删了。 枚举分割点 ppp，fl,r,k←fl,p,k+1+fp+1,r−1,0f_{l,r,k}\\leftarrow f_{l,p,k+1}+f_{p+1,r-1,0}fl,r,k​←fl,p,k+1​+fp+1,r−1,0​，并且需要满足 ppp 和 rrr 的 0/10/10/1 相同，表示我们先把 [p+1,r−1][p+1,r-1][p+1,r−1] 这一段删空，然后把 rrr 及其后面 kkk 个一共 k+1k+1k+1 个 0/10/10/1 丢到 ppp 之后，和 [l,p][l,p][l,p] 这一段区间一起删除。 然后朴素实现即可，时间复杂度 O(n4)O(n^4)O(n4)。感觉这个状态设计见过 inf 次了但是还是不会 /hanx /hanx。 12345678910111213141516171819202122#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int N = 110;int n, A[N], cnt[N]; LL C[N], DP[N][N][N];int main() { freopen(&quot;.in&quot;, &quot;r&quot;, stdin); freopen(&quot;.out&quot;, &quot;w&quot;, stdout); ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; char ch; for (int i = 1; i &lt;= n; i ++) { cin &gt;&gt; ch; A[i] = ch - '0'; } for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; C[i]; for (int i = 1; i &lt;= n; i ++) for (int j = 1; j &lt; i; j ++) C[i] = max(C[i], C[j] + C[i - j]); for (int i = 1; i &lt;= n; i ++) for (int j = i + 1; j &lt;= n; j ++) cnt[i] += (A[j] == A[i]); for (int len = 1; len &lt;= n; len ++) for (int l = 1; l &lt;= n - len + 1; l ++) { int r = l + len - 1; for (int k = l; k &lt; r; k ++) if (A[k] == A[r]) { for (int i = 0; i &lt;= cnt[r]; i ++) DP[l][r][i] = max(DP[l][k][i + 1] + DP[k + 1][r - 1][0], DP[l][r][i]); } for (int i = 0; i &lt;= cnt[r]; i ++) DP[l][r][i] = max(DP[l][r][i], DP[l][r - 1][0] + C[i + 1]); } cout &lt;&lt; DP[1][n][0] &lt;&lt; &quot;\\n&quot;; return 0;}","link":"/2025/03/18/CF1107E-sol/"},{"title":"简单题再次不会做，今天第二次退役。","text":"CF1860E. Fast Travel Text Editor。煎蛋题。 给定长度为 nnn 的小写字母字符串，你有一个光标，光标在每一个时刻只能位于相邻两个字符之间：可以移动光标，有两种移动方式： 往前（仅当光标不在第一个字符之后）或往后（仅当光标不在最后一个字符之前）一格 移动到一个位置满足其两边的字符和光标所在位置两边的字符相同。 QQQ 次询问，指定 s,ts,ts,t，求从 sss 到 ttt 光标最小移动次数。 先考虑一次询问怎么做。很 naive 的问题，首先往前往后可以直接连边，边权为 111，第二种移动方式连边数量太多，考虑对于每一种字符对建一个虚点，每个位置向他对应的左右字符对连一条边权 111 的单向边，虚点反过来连一条边权为 000 的单向边。此时两个点的最短路就是答案。单次询问时间复杂度 O(n)O(n)O(n)，使用 01 BFS 做最短路。 但是多次询问每次跑最短路显然不理想。我们注意到虚点个数只有 262=67626^2=676262=676 个，并且两个点的最短路，要么直接一格一格移动到达，否则必须经过至少一个虚点。我们处理出 fi,j,gi,jf_{i,j},g_{i,j}fi,j​,gi,j​ 分别表示从第 iii 个虚点到 jjj 位置的最短路和从 jjj 位置到第 iii 个虚点的最短路，于是枚举中转的是哪个虚点即可，也就是说，对于一个询问 (s,t)(s,t)(s,t)，答案为： Answer=min⁡(∣s−t∣,min⁡i=1676fi,s+gi,t).\\text{Answer}=\\min(|s-t|, \\min_{i=1}^{676} f_{i,s} + g_{i,t}). Answer=min(∣s−t∣,i=1min676​fi,s​+gi,t​). 总时间复杂度 O((n+q)V2)O((n+q)V^2)O((n+q)V2)，VVV 表示字符集大小，使用 01 BFS 求最短路。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int N = 8e4 + 10;const int V = 26 * 26;int n, m; char S[N]; vector&lt;pair&lt;int, int&gt; &gt; G[N], F[N]; int dist1[V][N], dist2[V][N];int q[N * 2]; int main() { freopen(&quot;.in&quot;, &quot;r&quot;, stdin); freopen(&quot;.out&quot;, &quot;w&quot;, stdout); ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; (S + 1) &gt;&gt; m; n = strlen(S + 1); for (int i = 1; i &lt; n; i ++) { if (i &gt; 1) G[i].emplace_back(make_pair(i - 1, 1)), F[i].emplace_back(make_pair(i - 1, 1)); if (i &lt; n - 1) G[i].emplace_back(make_pair(i + 1, 1)), F[i].emplace_back(make_pair(i + 1, 1)); int t = (S[i] - 'a') * 26 + S[i + 1] - 'a'; G[i].emplace_back(make_pair(n + t + 1, 1)); G[n + t + 1].emplace_back(make_pair(i, 0)); F[n + t + 1].emplace_back(make_pair(i, 1)); F[i].emplace_back(make_pair(n + t + 1, 1)); } for (int i = 0; i &lt; V; i ++) { for (int j = 1; j &lt;= n + V; j ++) dist1[i][j] = dist2[i][j] = 1e9; dist1[i][n + i + 1] = dist2[i][n + i + 1] = 0; int fr = n + V, tl = n + V; q[fr] = n + i + 1; while (fr &lt;= tl) { int u = q[fr ++]; for (auto [v, w] : G[u]) if (dist1[i][v] &gt; dist1[i][u] + w) { if (!w) { q[-- fr] = v; dist1[i][v] = dist1[i][u]; } else { q[++ tl] = v; dist1[i][v] = dist1[i][u] + 1; } } } fr = n + V, tl = n + V; q[fr] = n + i + 1; while (fr &lt;= tl) { int u = q[fr ++]; for (auto [v, w] : F[u]) if (dist2[i][v] &gt; dist2[i][u] + w) { if (!w) { q[-- fr] = v; dist2[i][v] = dist2[i][u]; } else { q[++ tl] = v; dist2[i][v] = dist2[i][u] + 1; } } } } while (m --) { int u, v; cin &gt;&gt; u &gt;&gt; v; int Ans = abs(v - u); for (int i = 0; i &lt; V; i ++) Ans = min(Ans, dist1[i][u] + dist2[i][v]); cout &lt;&lt; Ans &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2025/03/18/CF1860E-sol/"},{"title":"看来我还是不会区间 dp &#x2F;ll","text":"CF1922F - Replace on Segment。区间 dp 经典题，典题都不会做了唉唉。 给定长度为 nnn 值域为 [1,x][1,x][1,x] 的正整数序列 aaa，每次操作可以选择其一个区间 [l,r][l,r][l,r]，以及一个正整数 k∈[1,x]k\\in[1,x]k∈[1,x]，需要保证序列中 [l,r][l,r][l,r] 这个区间不包含 kkk，然后把这个区间全部数赋值为 kkk，问把整个序列变成相同最少操作数。 显然是区间 dp，但是使用区间 dp 之前先要证明至少存在一种最优解使得没有两个操作区间相交且不包含，感性理解一下，如果对于任意一种最优解，我们进行以下操作直到其不存在相交区间：选择任意两个相交的操作区间，并让其中一个改为完全包含另一个，容易发现这样一定不劣，于是可以使用区间 dp。 我们定义 fl,r,k,0/1f_{l,r,k,0/1}fl,r,k,0/1​ 表示把区间 [l,r][l,r][l,r] 变成全部都不是或是 kkk 的最少操作数。定义 fl,r,k,1f_{l,r,k,1}fl,r,k,1​ 的目的很显然，我们需要求他，而定义 fl,r,k,0f_{l,r,k,0}fl,r,k,0​ 的目的则是因为存在一种转移，我们可以先把整个区间染成不是 kkk，再花一步染成 kkk，所以定义了这个。转移： 枚举分界点 p∈[l,r)p\\in[l,r)p∈[l,r)，fl,r,k,0←fl,p,k,0+fp+1,r,k,0f_{l,r,k,0}\\leftarrow f_{l,p,k,0}+f_{p+1,r,k,0}fl,r,k,0​←fl,p,k,0​+fp+1,r,k,0​，fl,r,k,1←fl,p,k,1+fp+1,r,k,1f_{l,r,k,1}\\leftarrow f_{l,p,k,1}+f_{p+1,r,k,1}fl,r,k,1​←fl,p,k,1​+fp+1,r,k,1​，如果当前区间 [l,r][l,r][l,r] 不操作，那么就分治到左右两个区间操作。 枚举 p≠kp\\neq kp=k，fl,r,k,0←fl,r,p,0+1f_{l,r,k,0}\\leftarrow f_{l,r,p,0}+1fl,r,k,0​←fl,r,p,0​+1，也就是整个区间不是 ppp 的情况下全部赋为 ppp，然后就都不是 kkk 了，但是这里能发现会有循环转移，但是注意到 fl,r,k,0f_{l,r,k,0}fl,r,k,0​ 最小的那个 kkk 不会改变，于是求出最小值然后用它更新其他值。 fl,r,k,1←fl,r,k,0+1f_{l,r,k,1}\\leftarrow f_{l,r,k,0}+1fl,r,k,1​←fl,r,k,0​+1，整个区间操作一次 kkk 即可。 最后答案即为 min⁡f1,n,k\\min f_{1,n,k}minf1,n,k​。初始值有两种，如果整个区间 [l,r][l,r][l,r] 都为 kkk，那么有 fl,r,k,1=0f_{l,r,k,1}=0fl,r,k,1​=0，如果整个区间都没有 kkk，那么 fl,r,k,0=0f_{l,r,k,0}=0fl,r,k,0​=0。然后做完了。 12345678910111213141516171819202122232425262728293031323334353637#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int N = 110;int n, m, DP[N][N][N][2], A[N]; bool vis[N];int main() { freopen(&quot;.in&quot;, &quot;r&quot;, stdin); freopen(&quot;.out&quot;, &quot;w&quot;, stdout); ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); int _; cin &gt;&gt; _; while (_ --) { cin &gt;&gt; n &gt;&gt; m; for (int i = 1; i &lt;= n; i ++) cin &gt;&gt; A[i]; for (int i = 1; i &lt;= n; i ++) for (int j = i; j &lt;= n; j ++) for (int k = 1; k &lt;= m; k ++) DP[i][j][k][0] = DP[i][j][k][1] = 1e9; for (int len = 1; len &lt;= n; len ++) for (int l = 1; l &lt;= n - len + 1; l ++) { int r = l + len - 1, mn = 1e9; for (int i = 1; i &lt;= m; i ++) vis[i] = 0; for (int i = l; i &lt;= r; i ++) vis[A[i]] = 1; bool flag = true; for (int i = l; i &lt; r; i ++) flag &amp;= A[i] == A[i + 1]; if (flag) { DP[l][r][A[l]][1] = 0; } for (int k = 1; k &lt;= m; k ++) { if (!vis[k]) DP[l][r][k][0] = 0; for (int i = l; i &lt; r; i ++) DP[l][r][k][0] = min(DP[l][r][k][0], DP[l][i][k][0] + DP[i + 1][r][k][0]), DP[l][r][k][1] = min(DP[l][r][k][1], DP[l][i][k][1] + DP[i + 1][r][k][1]); mn = min(mn, DP[l][r][k][0]); } for (int k = 1; k &lt;= m; k ++) DP[l][r][k][0] = min(DP[l][r][k][0], mn + 1), DP[l][r][k][1] = min(DP[l][r][k][1], DP[l][r][k][0] + 1); } int Ans = 1e9; for (int k = 1; k &lt;= m; k ++) Ans = min(DP[1][n][k][1], Ans); cout &lt;&lt; Ans &lt;&lt; &quot;\\n&quot;; } return 0;}","link":"/2025/03/18/CF1922F-sol/"},{"title":"再也不诋毁 ABC 出板题了。","text":"ABC396G Flip Row or Col。不带脑子都能做的 FWT 题。赛时这么多人过是不是都贺的板子还是用的 AtCoder Library /fn，使得 diff 2195 紫题。 给定一个 010101 矩阵 AAA，长 HHH，宽 WWW，可以任意次数取反某一行或某一列，使得矩阵内数总和最小，求这个最小值。H≤2×105,W≤18H\\leq 2\\times 10^5,W\\leq 18H≤2×105,W≤18。 注意到 WWW 很小，于是我们把每一行的状态压成一个二进制数 aia_iai​ 方便处理。 先考虑一个朴素做法，能发现每一列被取反的结果只和取反次数模 222 有关，也就是每一列的取反结果是一个 0/10/10/1，所以我们枚举一个 WWW 位的二进制数 www 表示每一列是否被取反了。然后枚举每一行，这一行最终结果要么是 ai⊕wa_i\\oplus wai​⊕w 要么是 ai⊕wa_i\\oplus wai​⊕w 取反，所以这一行的总和最小即为 min⁡(popcount(ai⊕w),W−popcount(ai⊕w))\\min(\\text{popcount}(a_i\\oplus w),W-\\text{popcount}(a_i\\oplus w))min(popcount(ai​⊕w),W−popcount(ai​⊕w))，于是当列的状态为 www 的答案便是每一行的前面这个 min⁡\\minmin 求和。然后对每个 www 的答案取最小值就是总答案。时间复杂度 O(H2W)O(H2^W)O(H2W)。 我们记 f(x)=min⁡(popcount(x),W−popcount(x))f(x)=\\min(\\text{popcount}(x),W-\\text{popcount}(x))f(x)=min(popcount(x),W−popcount(x))，h(w)h(w)h(w) 表示列的状态为 www 的答案，那么有： h(w)=∑i=1nf(ai⊕w).h(w)=\\sum_{i=1}^n f(a_i \\oplus w). h(w)=i=1∑n​f(ai​⊕w). 注意到，ai⊕(ai⊕w)=wa_i\\oplus (a_i\\oplus w)=wai​⊕(ai​⊕w)=w，于是我们开一个桶 g(i)g(i)g(i) 表示 iii 在 aaa 序列中出现了几次，那么有： h(w)=∑x⊕y=wg(x)f(y),h=g∗f.h(w)=\\sum_{x\\oplus y=w}g(x)f(y),h=g*f. h(w)=x⊕y=w∑​g(x)f(y),h=g∗f. 然后就愉快地 FWT，做完了。 123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int N = 5e5 + 10;const LL MOD = 998244353;LL Qpow(LL x, LL k, LL P) { LL ret = 1, tmp = (x + P) % P; while (k) { if (k &amp; 1) ret = ret * tmp % P; tmp = tmp * tmp % P; k &gt;&gt;= 1; } return ret;}int n, m, A[N]; LL F[N], G[N]; void FWT(LL* A, int len, LL inv) { for (int i = 1; i &lt; len; i &lt;&lt;= 1) { int h = (i &lt;&lt; 1); for (int j = 0; j &lt; len; j += h) for (int k = 0; k &lt; i; k ++) { LL a = A[j + k], b = A[j + k + i]; A[j + k] = (a + b) * inv % MOD, A[j + k + i] = (a + MOD - b) * inv % MOD; } } return ;}int main() { freopen(&quot;.in&quot;, &quot;r&quot;, stdin); freopen(&quot;.out&quot;, &quot;w&quot;, stdout); ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n &gt;&gt; m; char x; for (int i = 1; i &lt;= n; i ++) { for (int j = 1; j &lt;= m; j ++) { cin &gt;&gt; x; A[i] = (A[i] &lt;&lt; 1) | (x - '0'); } G[A[i]] ++; } for (int i = 0; i &lt; (1 &lt;&lt; m); i ++) F[i] = min(__builtin_popcount(i), m - __builtin_popcount(i)); FWT(F, 1 &lt;&lt; m, 1); FWT(G, 1 &lt;&lt; m, 1); for (int i = 0; i &lt; (1 &lt;&lt; m); i ++) (F[i] *= G[i]) %= MOD; FWT(F, 1 &lt;&lt; m, Qpow(2, MOD - 2, MOD)); LL Ans = 1e18; for (int i = 0; i &lt; (1 &lt;&lt; m); i ++) Ans = min(Ans, F[i]); cout &lt;&lt; Ans; return 0;}","link":"/2025/03/18/at_abc396_g-sol/"}],"tags":[{"name":"maths","slug":"maths","link":"/tags/maths/"},{"name":"combinatorics","slug":"combinatorics","link":"/tags/combinatorics/"},{"name":"poly","slug":"poly","link":"/tags/poly/"},{"name":"greedy","slug":"greedy","link":"/tags/greedy/"},{"name":"trees","slug":"trees","link":"/tags/trees/"},{"name":"sqrt technology","slug":"sqrt-technology","link":"/tags/sqrt-technology/"},{"name":"binary search","slug":"binary-search","link":"/tags/binary-search/"},{"name":"CF-2600-2800","slug":"CF-2600-2800","link":"/tags/CF-2600-2800/"},{"name":"dp","slug":"dp","link":"/tags/dp/"},{"name":"tree","slug":"tree","link":"/tags/tree/"},{"name":"Luogu-提高+&#x2F;省选-","slug":"Luogu-提高-省选","link":"/tags/Luogu-%E6%8F%90%E9%AB%98-%E7%9C%81%E9%80%89/"},{"name":"data structure","slug":"data-structure","link":"/tags/data-structure/"},{"name":"Luogu-NOI&#x2F;NOI+&#x2F;CTSC","slug":"Luogu-NOI-NOI-CTSC","link":"/tags/Luogu-NOI-NOI-CTSC/"},{"name":"counting","slug":"counting","link":"/tags/counting/"},{"name":"AT-2400-2799","slug":"AT-2400-2799","link":"/tags/AT-2400-2799/"},{"name":"convex","slug":"convex","link":"/tags/convex/"},{"name":"AT-2800-3199","slug":"AT-2800-3199","link":"/tags/AT-2800-3199/"},{"name":"bitmasks","slug":"bitmasks","link":"/tags/bitmasks/"},{"name":"AT-2000-2399","slug":"AT-2000-2399","link":"/tags/AT-2000-2399/"},{"name":"CF-2400-2500","slug":"CF-2400-2500","link":"/tags/CF-2400-2500/"},{"name":"graph","slug":"graph","link":"/tags/graph/"},{"name":"shortest path","slug":"shortest-path","link":"/tags/shortest-path/"},{"name":"fwt","slug":"fwt","link":"/tags/fwt/"}],"categories":[{"name":"Solution","slug":"Solution","link":"/categories/Solution/"},{"name":"CodeForces","slug":"Solution/CodeForces","link":"/categories/Solution/CodeForces/"},{"name":"Ynoi","slug":"Solution/Ynoi","link":"/categories/Solution/Ynoi/"},{"name":"AtCoder","slug":"Solution/AtCoder","link":"/categories/Solution/AtCoder/"},{"name":"Luogu","slug":"Solution/Luogu","link":"/categories/Solution/Luogu/"},{"name":"dp","slug":"dp","link":"/categories/dp/"},{"name":"区间 dp","slug":"dp/区间-dp","link":"/categories/dp/%E5%8C%BA%E9%97%B4-dp/"},{"name":"convex","slug":"dp/convex","link":"/categories/dp/convex/"},{"name":"counting","slug":"dp/counting","link":"/categories/dp/counting/"},{"name":"tree","slug":"dp/tree","link":"/categories/dp/tree/"},{"name":"bitmasks","slug":"dp/bitmasks","link":"/categories/dp/bitmasks/"}],"pages":[]}