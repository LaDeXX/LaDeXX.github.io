{"posts":[{"title":"我不会简单组合数学","text":"容易发现这个 F(s,l,r)F(s,l,r)F(s,l,r) 事实上就是字符串 sss 中 [l,r][l,r][l,r] 这一段的 1\\mathtt{1}1 的个数减去 0\\mathtt{0}0 的个数。先考虑一个字符串怎么求出分数。 我们需要找到一个分界点 ppp，然后把左边的 FFF 值和右边的 FFF 值乘起来要求最大。观察到左右 FFF 值之和为定值，即整个字符串 1\\mathtt{1}1 的个数减去 0\\mathtt{0}0 的个数。于是猜想当左右 FFF 值各取一半时最大，或者当和为奇数的时候一个是一半上取整，一个是一半下取整是最大。答案确实如此，因为一定能找到一个 ppp，使得左右的 FFF 值满足这个。简单说明一下，能发现 ppp 每向后移动一位，左边的 FFF 值只会加一或减一，变化是连续的，因此一定能找到一个 ppp 使得左边的 FFF 值为一半，此时右边也相应满足。于是记 c0c_0c0​ 表示字符串 0\\mathtt{0}0 的个数，c1c_1c1​ 表示字符串 1\\mathtt{1}1 的个数，则价值为： ⌊(c1−c0)24⌋=(c1−c0)24−(c1−c0) mod 24.\\left\\lfloor\\frac{(c_1-c_0)^2}{4}\\right\\rfloor=\\frac{(c_1-c_0)^2}{4}-\\frac{(c_1-c_0)\\bmod 2}{4}. ⌊4(c1​−c0​)2​⌋=4(c1​−c0​)2​−4(c1​−c0​)mod2​. 你能发现一个序列的价值只和 01\\mathtt{01}01 个数之差有关。我们再来计算原序列的子序列的价值之和。我们考虑记 0\\mathtt{0}0 权值为 −1-1−1，1\\mathtt{1}1 权值为 111，然后一个字符串的价值就是其权值之和平方的下取整。对于一个 c0c_0c0​ 个 0\\mathtt{0}0，c1c_1c1​ 个 1\\mathtt{1}1 的字符串，我们统计它价值为 kkk 的子序列个数。我们枚举他选择了 iii 个 0\\mathtt{0}0，那么此时他选择了 k+ik+ik+i 个 1\\mathtt{1}1，那么总子序列个数就是： ∑i=0c0(c0i)(c1k+i)=∑i=0c0(c0c0−i)(c1k+i)=(c0+c1k+c0)=(nk+c0).\\sum_{i=0}^{c_0}\\binom{c_0}{i}\\binom{c_1}{k+i}=\\sum_{i=0}^{c_0}\\binom{c_0}{c_0-i}\\binom{c_1}{k+i}=\\binom{c_0+c_1}{k+c_0}=\\binom{n}{k+c_0}. i=0∑c0​​(ic0​​)(k+ic1​​)=i=0∑c0​​(c0​−ic0​​)(k+ic1​​)=(k+c0​c0​+c1​​)=(k+c0​n​). 左边的求和是一个范德蒙德卷积的推论。所以这个字符串所以子序列的价值之和就是： ∑i=−c0n−c0(nc0+i)(i24+i mod 24).\\sum_{i=-c_0}^{n-c_0}\\binom{n}{c_0+i}\\left(\\frac{i^2}{4}+\\frac{i\\bmod 2}{4}\\right). i=−c0​∑n−c0​​(c0​+in​)(4i2​+4imod2​). 预处理出所有 c0c_0c0​ 的答案即可 O(1)O(1)O(1) 询问，总复杂度 O(nlog⁡n+q)O(n\\log n+q)O(nlogn+q)，因为这里的处理需要简单 poly，具体可以看官解的代码（Python）。 我是 poly 菜鸡，于是我没有场切，所以我开始推狮子。这里需要的一些组合数性质可以先看 oiwiki。 我们把后面的取模分开处理。先求前面的平方除以四，再求后面的取模求和，这里我们可以把除以四放在最后，所以推式子里面没写。 ∑i=−c0n−c0(nc0+i)i2=∑i=0n(ni)(i−c0)2=∑i=0n(ni)i2−2c0∑i=0n(ni)i+c02∑i=0n(ni)=n(n+1)2n−2−2c0n2n−1+c022n.∑i=−c0n−c0(ni+c0)(i mod 2)=∑i=0n(ni)((i−c0) mod 2)=2n−1.\\begin{aligned} \\sum_{i=-c_0}^{n-c_0}\\binom{n}{c_0+i}i^2&amp;=\\sum_{i=0}^n\\binom{n}{i}(i-c_0)^2\\\\ &amp;=\\sum_{i=0}^n\\binom{n}{i}i^2-2c_0\\sum_{i=0}^n\\binom{n}{i}i+c_0^2\\sum_{i=0}^n\\binom{n}{i}\\\\ &amp;=n(n+1)2^{n-2}-2c_0n2^{n-1}+c_0^22^n.\\\\ \\sum_{i=-c_0}^{n-c_0}\\binom{n}{i+c_0}(i\\bmod 2)&amp;=\\sum_{i=0}^n\\binom{n}{i}\\left((i-c_0)\\bmod 2\\right)=2^{n-1}. \\end{aligned} i=−c0​∑n−c0​​(c0​+in​)i2i=−c0​∑n−c0​​(i+c0​n​)(imod2)​=i=0∑n​(in​)(i−c0​)2=i=0∑n​(in​)i2−2c0​i=0∑n​(in​)i+c02​i=0∑n​(in​)=n(n+1)2n−2−2c0​n2n−1+c02​2n.=i=0∑n​(in​)((i−c0​)mod2)=2n−1.​ 说明一下后面这个式子。他的具体意义就是求出所有 iii 为偶数或奇数的组合数之和。不论奇数还是偶数，组合数之和都是 2n−12^{n-1}2n−1 次方。 证明：考虑二项式定理，我们有 (1+x)n=∑i=0n(ni)xi(1+x)^n=\\sum_{i=0}^n \\binom{n}{i}x^i(1+x)n=∑i=0n​(in​)xi，代入 x=−1x=-1x=−1： (1−1)n=∑i=0n(ni)(−1)i=0.(1-1)^n=\\sum_{i=0}^n \\binom{n}{i}(-1)^i=0. (1−1)n=i=0∑n​(in​)(−1)i=0. 即： ∑i mod 2=0(ni)−∑i mod 2=1(ni)=0\\sum_{i\\bmod 2=0}\\binom{n}{i}-\\sum_{i\\bmod 2=1}\\binom{n}{i}=0 imod2=0∑​(in​)−imod2=1∑​(in​)=0 也就是 iii 为奇数和偶数分别求和是相等的，并且我们知道所有组合数之和是 2n2^n2n，从而 iii 为奇或偶是的和都是 2n−12^{n-1}2n−1。 最后把两个式子加起来。 4Answer=n(n+1)2n−2−2c0n2n−1+c022n+2n−1,Answer=2n−4(n2+n−4c0n−4c02+2).\\begin{aligned} 4\\text{Answer}&amp;=n(n+1)2^{n-2}-2c_0n2^{n-1}+c_0^22^n+2^{n-1},\\\\ \\text{Answer}&amp;=2^{n-4}(n^2+n-4c_0n-4c_0^2+2). \\end{aligned}4AnswerAnswer​=n(n+1)2n−2−2c0​n2n−1+c02​2n+2n−1,=2n−4(n2+n−4c0​n−4c02​+2).​ 然后直接做了，每次询问 O(1)O(1)O(1) 算一下即可。代码就不放了，十分甚至九分的简单罢。","link":"/2025/03/13/CF2077C-sol/"},{"title":"multiset 笑传之查（find）查棒","text":"前言：大家好，我喜欢用 multiset 维护可重集，并且删除一个元素 xxx 的时候使用了 multiset.erase(x) 而不是 multiset.erase(multiset.find(x))，成功导致我保龄并调试 40 mins40\\ \\text{mins}40 mins，祝大家不要重蹈覆辙。 先考虑朴素 dp，定义 fi,jf_{i,j}fi,j​ 表示第 iii 个事件发生的时候在 jjj 位置，最少的伤害总和。记 t=Ti−Ti−1t=T_i-T_{i-1}t=Ti​−Ti−1​，Ci(j)C_i(j)Ci​(j) 表示第 iii 次事件站在 jjj 所受伤害，有 fi,j=min⁡j−t≤k≤j+tfi−1,k+Ci(j).f_{i,j}=\\min_{j-t\\leq k\\leq j + t}f_{i-1,k}+C_i(j). fi,j​=j−t≤k≤j+tmin​fi−1,k​+Ci​(j). 这个 dp 是 O(nV)O(nV)O(nV) 的，直接倒闭了。然后你能发现这个转移的增量是一个关于 jjj 的凸函数，所以考虑 Slope Trick。先介绍一下 Slope Trick。 Slope Trick 可以维护一个由若干段一次函数组成的一个凸分段函数。我们考虑记录这若干段一次函数的分界点的集合，并且分界点出现一次表示斜率增加或减少 111，如果出现多次则说明减少若干斜率，以及记录这个凸函数最开始那一段的 k,bk,bk,b，比如： f(x)={1−x,x≤5,2x+8,x&gt;5.f(x)=\\left\\{\\begin{aligned}&amp;1-x,\\quad&amp;x\\leq 5,\\\\&amp;2x+8,&amp;x&gt;5.\\end{aligned}\\right. f(x)={​1−x,2x+8,​x≤5,x&gt;5.​ 这个函数在 Slope Trick 下维护出的集合就是 {5,5,5}\\{5,5,5\\}{5,5,5}，以及最开始一段的函数的 k=−1,b=1k=-1,b=1k=−1,b=1。所以这是一个可重集。 然后你会发现这个东西比较优美，可以有如下的操作： 加上一个凸函数：因为凸函数加凸函数还是凸函数，所以直接把分界点集合合并即可，然后更新一下最开始一段的斜率和截距。 平移：对分段点集合打全局加减标记即可。 函数的最值：这里就不大相同，我们不维护最左边的斜率和截距。以凸函数为例，函数最大值就是斜率为 000 的部分，所以我们考虑维护两个集合分别表示斜率为 000 的左边和右边的分界点即可。最值就是中介斜率为 000 的部分。 函数取前后缀 min⁡/max⁡\\min/\\maxmin/max：联系上一点，就是把斜率为 000 的左边或者右边丢掉。 回到本题，我们设 Fi(j)=fi,jF_i(j)=f_{i,j}Fi​(j)=fi,j​，我们发现这个就是一个凸函数（函数凹凸的图像和汉字形状是相反的 /xk）。本题我们需要支持加上一个凸函数，并且维护最小值，然后考虑转移式前面的那个 min⁡\\minmin，这个就相当于把斜率为 000 左边的部分向左移 ttt，右边的部分向右移 ttt。对于 Ci(j)C_i(j)Ci​(j)，它在 Di=0D_i=0Di​=0 的时候是斜率由 −1-1−1 变为 000，否则是 000 变为 111。考虑加入这个凸函数的时候怎么更新斜率为 000 的部分并且更新答案。 以 Di=0D_i=0Di​=0 为例，这时候函数大致呈 \\_ 状。我们记当前斜率为 000 的一段区间为 [l,r][l,r][l,r]，如果这个函数的拐点 XXX 大于等于 lll，我们发现只需要 XXX 加入右集合即可。否则要更新这个区间和答案。先吧 XXX 加入左集合，我们会发现，原来斜率为 000 的这个区间斜率变成了 −1-1−1，所以把 rrr 加入右集合表示斜率减少 111，然后更新答案。 Di=1D_i=1Di​=1 同理。 12345678910111213141516171819202122232425262728293031323334#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int N = 2e5 + 10;int n; LL T[N], D[N], X[N], Ans = 0;struct Heap { multiset&lt;LL&gt; s; LL tag; void insert(LL x) { s.insert(x - tag); } void erase(LL x) { s.erase(s.find(x - tag)); } LL min() { return *s.begin() + tag; } LL max() { return *s.rbegin() + tag; } void add(LL x) { tag += x; }} pql, pqr;int main() { freopen(&quot;.in&quot;, &quot;r&quot;, stdin); freopen(&quot;.out&quot;, &quot;w&quot;, stdout); ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; i ++) pql.insert(0), pqr.insert(0); for (int i = 1; i &lt;= n; i ++) { cin &gt;&gt; T[i] &gt;&gt; D[i] &gt;&gt; X[i]; LL len = T[i] - T[i - 1]; pql.add(-len); pqr.add(len); if (D[i]) { // _/ if (X[i] &gt;= pql.max()) { pqr.insert(X[i]); continue; } pql.insert(X[i]); LL r = pql.max(); pql.erase(r); pqr.insert(r); Ans += pqr.min() - X[i]; } else { // \\_ if (X[i] &lt;= pqr.min()) { pql.insert(X[i]); continue; } pqr.insert(X[i]); LL l = pqr.min(); pqr.erase(l); pql.insert(l); Ans += X[i] - pql.max(); } } cout &lt;&lt; Ans; return 0;}","link":"/2025/03/13/at_abc217_h-sol/"},{"title":"AT_arc168_e [ARC168E] Subsegments with Large Sums Solution","text":"wqs 二分好题。 看到恰好分成 kkk 段，于是往 wqs 二分去想，如果记 f(k)f(k)f(k) 表示分成 kkk 段的答案，你会发现这个不是凸的，然后我就烧烤半天毫无头猪。 换个地方考虑，我们发现答案是有单调性的，我们记 f(x)f(x)f(x) 表示答案为 xxx，即选出正好 xxx 个和大于 SSS 的区间是最多能分成多少段，则 f(x)f(x)f(x) 是递减的，我们需要找到最大的 xxx 满足 k≤f(x)k\\leq f(x)k≤f(x)。于是我们考虑二分答案 xxx，从而变成一个判定性问题：从序列中选出大于等于 xxx 段和大于 SSS 的区间，能否有一种方案使得区间总数大于 kkk。所以这里区间总数越大越好，于是有轻微贪心，我们记 pip_ipi​ 表示最后一个到 iii 的区间和大于等于 SSS 的位置，那么如果选择一个合法区间以 iii 结尾，那么一定左端点是 pip_ipi​，而非小于 pip_ipi​，并且除了合法区间以外的区间一定是单个数，这样选择的个数最多。这个 pip_ipi​ 可以直接双指针。 我们不妨想想如何清新地刻画这个区间个数，我们记一个区间的权值为其长度减一，那么你对原序列的一种划分区间方案中所有区间的权值之和就是 nnn 减去区间个数。于是我们的判定变成了：把序列划分成 kkk 段，并且有恰好 xxx 段和大于 SSS 的区间，求所有区间的权值之和最小值。如果最小值小于等于 n−kn-kn−k 说明 xxx 合法，否则不合法。 然后考虑这个子问题，发现我们记 g(i)g(i)g(i) 表示当 x=ix=ix=i 时上面这个问题的最小值，发现这是个凸函数（依照主流观点，向下凸出，是个下凸壳）。于是上 wqs 二分即可。 感性理解一下凸性，即证 g(i+1)−g(i)≥g(i)−g(i−1)g(i+1)-g(i)\\geq g(i)-g(i-1)g(i+1)−g(i)≥g(i)−g(i−1)。我们考虑这两次的决策，反证法，如果 g(i+1)−g(i)&lt;g(i)−g(i−1)g(i+1)-g(i)&lt; g(i)-g(i-1)g(i+1)−g(i)&lt;g(i)−g(i−1)，也就是说，当前第 i+1i+1i+1 次选择的区间的贡献小于第 iii 次选择的区间，因为我们要求的是最小值，那么显然前者可以在第 iii 次就选择，使得 g(i)g(i)g(i) 减小，从而使得 g(i)−g(i+1)≤g(i−1)−g(i)g(i)-g(i+1)\\leq g(i-1)-g(i)g(i)−g(i+1)≤g(i−1)−g(i)。 笔者代码实现中与上述描述唯一不同的是我记录的是 pi−1p_i - 1pi​−1 而不是 pip_ipi​。 https://atcoder.jp/contests/arc168/submissions/63405440。","link":"/2025/03/13/at_arc168_e-sol/"},{"title":"AT_abc395_g [ABC395G] Minimum Steiner Tree 2 Solution","text":"根据题目名称，我们知道我们需要贺一个最小斯坦纳树板子。 但是我们会发现，他每次询问会在前 KKK 个点之外增加两个点 s,ts,ts,t，于是我们考虑预处理答案然后 O(1)O(1)O(1) 询问，我们枚举 s,ts,ts,t，然后暴力重新跑一遍最小斯坦纳树。时间复杂度 O(n2(n3k+2+n22k+2))O(n^2(n3^{k+2}+n^22^{k+2}))O(n2(n3k+2+n22k+2))，倒闭了。 观察最原始的最小斯坦纳树的状压 dp，状态定义为 fi,sf_{i,s}fi,s​ 表示以 iii 为当前根覆盖集合 sss，也就是说，有一维已经被最小斯坦纳树的 dp 枚举过了，于是我们只需要枚举一维 ttt，然后 s,ts,ts,t 的答案就是用 sss 覆盖了 {1,2,⋯ ,k,t}\\{1,2,\\cdots,k,t\\}{1,2,⋯,k,t}，即 fs,{1,2,⋯ ,k,t}f_{s,\\{1,2,\\cdots,k,t\\}}fs,{1,2,⋯,k,t}​，或者 s,ts,ts,t 互换一下。然后做完了。时间复杂度少了一个 nnn，指数也少了 111，O(n23k+1+n32k+1)O(n^23^{k+1}+n^3 2^{k+1})O(n23k+1+n32k+1)。 https://atcoder.jp/contests/abc395/submissions/63295857。","link":"/2025/03/14/at_abc395_g-sol/"},{"title":"STL 颜面何在？如此成績，令人汗顏！","text":"今年 ARC 大賽，線性和線段樹做法大勝，STL 慘敗。羞也不羞，朋比為奸！我們需要嚴格的檢討！ 来一发 set 题解。 我们拿其中的某一个数 kkk 考虑，记序列中比它大的数为 000，比它小的为 111，手玩一下会发现是中位数情况只有两种： {⋯ ,0,1,0,1,k,0,1,0,1,⋯ },{⋯ ,1,0,1,0,k,1,0,1,0,⋯ }.\\{\\cdots,0,1,0,1,k,0,1,0,1,\\cdots\\},\\\\ \\{\\cdots,1,0,1,0,k,1,0,1,0,\\cdots\\}. {⋯,0,1,0,1,k,0,1,0,1,⋯},{⋯,1,0,1,0,k,1,0,1,0,⋯}. 也就是两边都 010101 交替，并且 kkk 两边不同为 000 或 111，那么非中位数的情况有： kkk 两边同为 000 或 111，答案为 333。 kkk 某一侧出现了连续两个同为 000 或 111，我们以右侧为例，记这两个连续相同的数的第二个的下标是 ppp，则当 p−k+1p-k+1p−k+1 为奇数时答案为 p−k+1p-k+1p−k+1，否则为 p−k+2p-k+2p−k+2。必要性是显然的因为区间长度必须奇数，但是充分性还需证明，为什么偶数时加入一个左边的数一定非法。我们假设 kkk 左侧相邻的数为 q∈{0,1}q\\in \\{0,1\\}q∈{0,1}，当 p−k+2p-k+2p−k+2 为偶数的时候，ppp 和 p−1p-1p−1 这两位上的 010101 等于 qqq（如果不等于 qqq，会归于上一种情况），而 kkk 到 ppp 这一段中当 ppp 这一位为 000 的时候大于 kkk 的更多，加上 qqq 这一位之后大于 kkk 的依然更多，所以不是中位数，当 ppp 这一位小于 000 同理，所以得证。当 ppp 在 kkk 左侧也同理，加入右侧第一个即可。 然后我们考虑维护，我们从小到大加入数字，标记为 111，便记录了这一个 010101 序列，然后用一个 setsetset 维护相邻相同的位置即可，每次 lower_bound 查询最近的第一个相邻就好了。 但是注意我们这样做需要保证 kkk 有左侧和右侧，所以序列首尾两个数要单独处理，会发现首尾两个数不是中位数是平凡的。以第一个数为例，[1,r][1,r][1,r] 这个序列可以作为答案当且仅当 rrr 是奇数并且 [2,r][2,r][2,r] 中大于 P1P_1P1​ 的个数不等于小于 P1P_1P1​ 的个数。这个也可以处理一个 010101 列然后前缀和一下。最后一个数也同理。 然后做完了。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647#include &lt;bits/stdc++.h&gt;#define LL long longusing namespace std;const int N = 3e5 + 10;int n, A[N], id[N], Ans[N], B[N];int main() { ios :: sync_with_stdio(0); cin.tie(0); cout.tie(0); cin &gt;&gt; n; for (int i = 1; i &lt;= n; id[A[i]] = i, i ++) cin &gt;&gt; A[i]; memset(Ans, -1, sizeof Ans); for (int i = 2; i &lt;= n; i ++) B[i] = B[i - 1] + (A[i] &gt; A[1]); for (int i = 3; i &lt;= n; i += 2) if (B[i] != i / 2) { Ans[1] = i; break; } B[n] = 0; for (int i = n - 1; i &gt;= 1; i --) B[i] = B[i + 1] + (A[i] &gt; A[n]); for (int i = n - 2; i &gt;= 1; i -= 2) if (B[i] != (n - i) / 2) { Ans[n] = n - i + 1; break; } set&lt;int&gt; s; for (int i = 1; i &lt;= n - 1; i ++) s.insert(i); for (int i = 1; i &lt;= n; i ++) { int u = id[i]; if (u != 1 &amp;&amp; u != n) { if ((A[u - 1] &lt; A[u]) == (A[u + 1] &lt; A[u])) Ans[u] = 3; else { auto it = s.lower_bound(u + 1); if (it != s.end()) { int tmp = *it - u + 2; if (tmp % 2 == 0) ++ tmp; if (Ans[u] == -1) Ans[u] = tmp; else Ans[u] = min(Ans[u], tmp); } it = s.lower_bound(u - 1); if (it != s.begin()) { it --; int tmp = u - *it + 1; if (tmp % 2 == 0) ++ tmp; if (Ans[u] == -1) Ans[u] = tmp; else Ans[u] = min(Ans[u], tmp); } } } if (u &gt; 1) { if (A[u - 1] &lt; i) s.insert(u - 1); else s.erase(u - 1); } if (u &lt; n) { if (A[u + 1] &lt; i) s.insert(u); else s.erase(u); } } for (int i = 1; i &lt;= n; i ++) cout &lt;&lt; Ans[i] &lt;&lt; &quot; \\n&quot;[i == n]; return 0;}","link":"/2025/03/13/at_arc173_c-sol/"}],"tags":[],"categories":[],"pages":[]}